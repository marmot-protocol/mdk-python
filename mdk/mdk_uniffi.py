# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
from dataclasses import dataclass
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform


# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_mdk_uniffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_mdk_uniffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_mdk_uniffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError(f"junk data left in buffer at end of consume_with_stream {s.remaining()}")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError(f"junk data left in buffer at end of read_with_stream {s.remaining()}")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiFfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiFfiConverterString.lower(repr(e))
# Initial value and increment amount for handles. 
# These ensure that Python-generated handles always have the lowest bit set
_UNIFFI_HANDLEMAP_INITIAL = 1
_UNIFFI_HANDLEMAP_DELTA = 2

class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = _UNIFFI_HANDLEMAP_INITIAL

    def insert(self, obj):
        with self._lock:
            return self._insert(obj)

    """Low-level insert, this assumes `self._lock` is held."""
    def _insert(self, obj):
        handle = self._counter
        self._counter += _UNIFFI_HANDLEMAP_DELTA
        self._map[handle] = obj
        return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.get: Invalid handle {handle}")

    def clone(self, handle):
        try:
            with self._lock:
                obj = self._map[handle]
                return self._insert(obj)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.clone: Invalid handle {handle}")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError(f"_UniffiHandleMap.remove: Invalid handle: {handle}")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("mdk_uniffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 30
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_mdk_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_mdk_uniffi_checksum_func_decrypt_group_image() != 29409:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_func_derive_upload_keypair() != 45595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_func_new_mdk() != 40772:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_func_new_mdk_unencrypted() != 29834:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_func_new_mdk_with_key() != 29974:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_func_prepare_group_image_for_upload() != 65092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome() != 3695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome_json() != 39652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_add_members() != 19089:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_create_group() != 56895:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event() != 46847:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event_with_options() != 59356:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_create_message() != 58601:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome() != 57917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome_json() != 21478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_group() != 1495:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_groups() != 20872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_last_message() != 16338:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_members() != 9763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_message() != 47057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_messages() != 47346:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_pending_welcomes() != 31211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_relays() != 55523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_get_welcome() != 25012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_leave_group() != 46166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_merge_pending_commit() != 22201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_parse_key_package() != 41870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_process_message() != 15589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_process_welcome() != 34932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_remove_members() != 31926:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_self_update() != 48999:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_sync_group_metadata_from_mls() != 16922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_mdk_uniffi_checksum_method_mdk_update_group_data() != 32068:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UniffiLib.ffi_mdk_uniffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_mdk_uniffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_mdk_uniffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rustbuffer_free.restype = None
_UniffiLib.ffi_mdk_uniffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFutureDroppedCallbackStruct(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_DROPPED_CALLBACK),
    ]
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_mdk_uniffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_mdk_uniffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_mdk_uniffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_mdk_uniffi_rust_future_complete_void.restype = None
_UniffiLib.ffi_mdk_uniffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_mdk_uniffi_rust_future_free_void.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_clone_mdk.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_clone_mdk.restype = ctypes.c_uint64
_UniffiLib.uniffi_mdk_uniffi_fn_free_mdk.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_free_mdk.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_func_decrypt_group_image.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_func_decrypt_group_image.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_func_derive_upload_keypair.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_func_derive_upload_keypair.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk.restype = ctypes.c_uint64
_UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk_unencrypted.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk_unencrypted.restype = ctypes.c_uint64
_UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk_with_key.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk_with_key.restype = ctypes.c_uint64
_UniffiLib.uniffi_mdk_uniffi_fn_func_prepare_group_image_for_upload.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_func_prepare_group_image_for_upload.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_accept_welcome.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_accept_welcome.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_accept_welcome_json.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_accept_welcome_json.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_add_members.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_add_members.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_group.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_group.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event_with_options.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event_with_options.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_message.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint16,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_decline_welcome.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_decline_welcome.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_decline_welcome_json.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_decline_welcome_json.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_group.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_group.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_groups.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_groups.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_last_message.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_last_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_members.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_members.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_message.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_messages.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_messages.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_pending_welcomes.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_pending_welcomes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_relays.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_relays.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_welcome.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_welcome.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_leave_group.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_leave_group.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_merge_pending_commit.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_merge_pending_commit.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_parse_key_package.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_parse_key_package.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_process_message.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_process_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_process_welcome.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_process_welcome.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_remove_members.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_remove_members.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_self_update.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_self_update.restype = _UniffiRustBuffer
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_sync_group_metadata_from_mls.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_sync_group_metadata_from_mls.restype = None
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_update_group_data.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_update_group_data.restype = _UniffiRustBuffer
_UniffiLib.ffi_mdk_uniffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_mdk_uniffi_uniffi_contract_version.restype = ctypes.c_uint32
_UniffiLib.uniffi_mdk_uniffi_checksum_func_decrypt_group_image.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_func_decrypt_group_image.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_func_derive_upload_keypair.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_func_derive_upload_keypair.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_func_new_mdk.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_func_new_mdk.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_func_new_mdk_unencrypted.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_func_new_mdk_unencrypted.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_func_new_mdk_with_key.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_func_new_mdk_with_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_func_prepare_group_image_for_upload.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_func_prepare_group_image_for_upload.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome_json.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_add_members.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_add_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_group.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event_with_options.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event_with_options.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_message.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_create_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome_json.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_group.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_groups.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_groups.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_last_message.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_last_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_members.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_message.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_messages.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_messages.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_pending_welcomes.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_pending_welcomes.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_relays.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_relays.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_welcome.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_get_welcome.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_leave_group.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_leave_group.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_merge_pending_commit.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_merge_pending_commit.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_parse_key_package.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_parse_key_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_process_message.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_process_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_process_welcome.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_process_welcome.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_remove_members.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_remove_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_self_update.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_self_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_sync_group_metadata_from_mls.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_sync_group_metadata_from_mls.restype = ctypes.c_uint16
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_update_group_data.argtypes = (
)
_UniffiLib.uniffi_mdk_uniffi_checksum_method_mdk_update_group_data.restype = ctypes.c_uint16

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)



# Public interface members begin here.


class _UniffiFfiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiFfiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

class _UniffiFfiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterString.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiFfiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class Group:
    """
    Group representation
"""
    def __init__(self, *, mls_group_id:str, nostr_group_id:str, name:str, description:str, image_hash:typing.Optional[bytes], image_key:typing.Optional[bytes], image_nonce:typing.Optional[bytes], admin_pubkeys:typing.List[str], last_message_id:typing.Optional[str], last_message_at:typing.Optional[int], last_message_processed_at:typing.Optional[int], epoch:int, state:str):
        self.mls_group_id = mls_group_id
        self.nostr_group_id = nostr_group_id
        self.name = name
        self.description = description
        self.image_hash = image_hash
        self.image_key = image_key
        self.image_nonce = image_nonce
        self.admin_pubkeys = admin_pubkeys
        self.last_message_id = last_message_id
        self.last_message_at = last_message_at
        self.last_message_processed_at = last_message_processed_at
        self.epoch = epoch
        self.state = state
        
        

    
    def __str__(self):
        return "Group(mls_group_id={}, nostr_group_id={}, name={}, description={}, image_hash={}, image_key={}, image_nonce={}, admin_pubkeys={}, last_message_id={}, last_message_at={}, last_message_processed_at={}, epoch={}, state={})".format(self.mls_group_id, self.nostr_group_id, self.name, self.description, self.image_hash, self.image_key, self.image_nonce, self.admin_pubkeys, self.last_message_id, self.last_message_at, self.last_message_processed_at, self.epoch, self.state)
    def __eq__(self, other):
        if self.mls_group_id != other.mls_group_id:
            return False
        if self.nostr_group_id != other.nostr_group_id:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.image_hash != other.image_hash:
            return False
        if self.image_key != other.image_key:
            return False
        if self.image_nonce != other.image_nonce:
            return False
        if self.admin_pubkeys != other.admin_pubkeys:
            return False
        if self.last_message_id != other.last_message_id:
            return False
        if self.last_message_at != other.last_message_at:
            return False
        if self.last_message_processed_at != other.last_message_processed_at:
            return False
        if self.epoch != other.epoch:
            return False
        if self.state != other.state:
            return False
        return True

class _UniffiFfiConverterTypeGroup(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Group(
            mls_group_id=_UniffiFfiConverterString.read(buf),
            nostr_group_id=_UniffiFfiConverterString.read(buf),
            name=_UniffiFfiConverterString.read(buf),
            description=_UniffiFfiConverterString.read(buf),
            image_hash=_UniffiFfiConverterOptionalBytes.read(buf),
            image_key=_UniffiFfiConverterOptionalBytes.read(buf),
            image_nonce=_UniffiFfiConverterOptionalBytes.read(buf),
            admin_pubkeys=_UniffiFfiConverterSequenceString.read(buf),
            last_message_id=_UniffiFfiConverterOptionalString.read(buf),
            last_message_at=_UniffiFfiConverterOptionalUInt64.read(buf),
            last_message_processed_at=_UniffiFfiConverterOptionalUInt64.read(buf),
            epoch=_UniffiFfiConverterUInt64.read(buf),
            state=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.mls_group_id)
        _UniffiFfiConverterString.check_lower(value.nostr_group_id)
        _UniffiFfiConverterString.check_lower(value.name)
        _UniffiFfiConverterString.check_lower(value.description)
        _UniffiFfiConverterOptionalBytes.check_lower(value.image_hash)
        _UniffiFfiConverterOptionalBytes.check_lower(value.image_key)
        _UniffiFfiConverterOptionalBytes.check_lower(value.image_nonce)
        _UniffiFfiConverterSequenceString.check_lower(value.admin_pubkeys)
        _UniffiFfiConverterOptionalString.check_lower(value.last_message_id)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.last_message_at)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.last_message_processed_at)
        _UniffiFfiConverterUInt64.check_lower(value.epoch)
        _UniffiFfiConverterString.check_lower(value.state)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.mls_group_id, buf)
        _UniffiFfiConverterString.write(value.nostr_group_id, buf)
        _UniffiFfiConverterString.write(value.name, buf)
        _UniffiFfiConverterString.write(value.description, buf)
        _UniffiFfiConverterOptionalBytes.write(value.image_hash, buf)
        _UniffiFfiConverterOptionalBytes.write(value.image_key, buf)
        _UniffiFfiConverterOptionalBytes.write(value.image_nonce, buf)
        _UniffiFfiConverterSequenceString.write(value.admin_pubkeys, buf)
        _UniffiFfiConverterOptionalString.write(value.last_message_id, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.last_message_at, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.last_message_processed_at, buf)
        _UniffiFfiConverterUInt64.write(value.epoch, buf)
        _UniffiFfiConverterString.write(value.state, buf)

@dataclass
class CreateGroupResult:
    """
    Result of creating a group
"""
    def __init__(self, *, group:Group, welcome_rumors_json:typing.List[str]):
        self.group = group
        self.welcome_rumors_json = welcome_rumors_json
        
        

    
    def __str__(self):
        return "CreateGroupResult(group={}, welcome_rumors_json={})".format(self.group, self.welcome_rumors_json)
    def __eq__(self, other):
        if self.group != other.group:
            return False
        if self.welcome_rumors_json != other.welcome_rumors_json:
            return False
        return True

class _UniffiFfiConverterTypeCreateGroupResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CreateGroupResult(
            group=_UniffiFfiConverterTypeGroup.read(buf),
            welcome_rumors_json=_UniffiFfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterTypeGroup.check_lower(value.group)
        _UniffiFfiConverterSequenceString.check_lower(value.welcome_rumors_json)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterTypeGroup.write(value.group, buf)
        _UniffiFfiConverterSequenceString.write(value.welcome_rumors_json, buf)

class _UniffiFfiConverterOptionalOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterOptionalBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterOptionalBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterOptionalBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class GroupDataUpdate:
    """
    Configuration for updating group data with optional fields
"""
    def __init__(self, *, name:typing.Optional[str], description:typing.Optional[str], image_hash:typing.Optional[typing.Optional[bytes]], image_key:typing.Optional[typing.Optional[bytes]], image_nonce:typing.Optional[typing.Optional[bytes]], relays:typing.Optional[typing.List[str]], admins:typing.Optional[typing.List[str]]):
        self.name = name
        self.description = description
        self.image_hash = image_hash
        self.image_key = image_key
        self.image_nonce = image_nonce
        self.relays = relays
        self.admins = admins
        
        

    
    def __str__(self):
        return "GroupDataUpdate(name={}, description={}, image_hash={}, image_key={}, image_nonce={}, relays={}, admins={})".format(self.name, self.description, self.image_hash, self.image_key, self.image_nonce, self.relays, self.admins)
    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.image_hash != other.image_hash:
            return False
        if self.image_key != other.image_key:
            return False
        if self.image_nonce != other.image_nonce:
            return False
        if self.relays != other.relays:
            return False
        if self.admins != other.admins:
            return False
        return True

class _UniffiFfiConverterTypeGroupDataUpdate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GroupDataUpdate(
            name=_UniffiFfiConverterOptionalString.read(buf),
            description=_UniffiFfiConverterOptionalString.read(buf),
            image_hash=_UniffiFfiConverterOptionalOptionalBytes.read(buf),
            image_key=_UniffiFfiConverterOptionalOptionalBytes.read(buf),
            image_nonce=_UniffiFfiConverterOptionalOptionalBytes.read(buf),
            relays=_UniffiFfiConverterOptionalSequenceString.read(buf),
            admins=_UniffiFfiConverterOptionalSequenceString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalString.check_lower(value.name)
        _UniffiFfiConverterOptionalString.check_lower(value.description)
        _UniffiFfiConverterOptionalOptionalBytes.check_lower(value.image_hash)
        _UniffiFfiConverterOptionalOptionalBytes.check_lower(value.image_key)
        _UniffiFfiConverterOptionalOptionalBytes.check_lower(value.image_nonce)
        _UniffiFfiConverterOptionalSequenceString.check_lower(value.relays)
        _UniffiFfiConverterOptionalSequenceString.check_lower(value.admins)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalString.write(value.name, buf)
        _UniffiFfiConverterOptionalString.write(value.description, buf)
        _UniffiFfiConverterOptionalOptionalBytes.write(value.image_hash, buf)
        _UniffiFfiConverterOptionalOptionalBytes.write(value.image_key, buf)
        _UniffiFfiConverterOptionalOptionalBytes.write(value.image_nonce, buf)
        _UniffiFfiConverterOptionalSequenceString.write(value.relays, buf)
        _UniffiFfiConverterOptionalSequenceString.write(value.admins, buf)

class _UniffiFfiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

@dataclass
class ImageDimensions:
    """
    Image dimensions
"""
    def __init__(self, *, width:int, height:int):
        self.width = width
        self.height = height
        
        

    
    def __str__(self):
        return "ImageDimensions(width={}, height={})".format(self.width, self.height)
    def __eq__(self, other):
        if self.width != other.width:
            return False
        if self.height != other.height:
            return False
        return True

class _UniffiFfiConverterTypeImageDimensions(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ImageDimensions(
            width=_UniffiFfiConverterUInt32.read(buf),
            height=_UniffiFfiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterUInt32.check_lower(value.width)
        _UniffiFfiConverterUInt32.check_lower(value.height)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterUInt32.write(value.width, buf)
        _UniffiFfiConverterUInt32.write(value.height, buf)

class _UniffiFfiConverterOptionalTypeImageDimensions(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeImageDimensions.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeImageDimensions.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeImageDimensions.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class GroupImageUpload:
    """
    Prepared group image data ready for upload to Blossom
"""
    def __init__(self, *, encrypted_data:bytes, encrypted_hash:bytes, image_key:bytes, image_nonce:bytes, upload_secret_key:str, original_size:int, encrypted_size:int, mime_type:str, dimensions:typing.Optional[ImageDimensions], blurhash:typing.Optional[str]):
        self.encrypted_data = encrypted_data
        self.encrypted_hash = encrypted_hash
        self.image_key = image_key
        self.image_nonce = image_nonce
        self.upload_secret_key = upload_secret_key
        self.original_size = original_size
        self.encrypted_size = encrypted_size
        self.mime_type = mime_type
        self.dimensions = dimensions
        self.blurhash = blurhash
        
        

    
    def __str__(self):
        return "GroupImageUpload(encrypted_data={}, encrypted_hash={}, image_key={}, image_nonce={}, upload_secret_key={}, original_size={}, encrypted_size={}, mime_type={}, dimensions={}, blurhash={})".format(self.encrypted_data, self.encrypted_hash, self.image_key, self.image_nonce, self.upload_secret_key, self.original_size, self.encrypted_size, self.mime_type, self.dimensions, self.blurhash)
    def __eq__(self, other):
        if self.encrypted_data != other.encrypted_data:
            return False
        if self.encrypted_hash != other.encrypted_hash:
            return False
        if self.image_key != other.image_key:
            return False
        if self.image_nonce != other.image_nonce:
            return False
        if self.upload_secret_key != other.upload_secret_key:
            return False
        if self.original_size != other.original_size:
            return False
        if self.encrypted_size != other.encrypted_size:
            return False
        if self.mime_type != other.mime_type:
            return False
        if self.dimensions != other.dimensions:
            return False
        if self.blurhash != other.blurhash:
            return False
        return True

class _UniffiFfiConverterTypeGroupImageUpload(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GroupImageUpload(
            encrypted_data=_UniffiFfiConverterBytes.read(buf),
            encrypted_hash=_UniffiFfiConverterBytes.read(buf),
            image_key=_UniffiFfiConverterBytes.read(buf),
            image_nonce=_UniffiFfiConverterBytes.read(buf),
            upload_secret_key=_UniffiFfiConverterString.read(buf),
            original_size=_UniffiFfiConverterUInt64.read(buf),
            encrypted_size=_UniffiFfiConverterUInt64.read(buf),
            mime_type=_UniffiFfiConverterString.read(buf),
            dimensions=_UniffiFfiConverterOptionalTypeImageDimensions.read(buf),
            blurhash=_UniffiFfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterBytes.check_lower(value.encrypted_data)
        _UniffiFfiConverterBytes.check_lower(value.encrypted_hash)
        _UniffiFfiConverterBytes.check_lower(value.image_key)
        _UniffiFfiConverterBytes.check_lower(value.image_nonce)
        _UniffiFfiConverterString.check_lower(value.upload_secret_key)
        _UniffiFfiConverterUInt64.check_lower(value.original_size)
        _UniffiFfiConverterUInt64.check_lower(value.encrypted_size)
        _UniffiFfiConverterString.check_lower(value.mime_type)
        _UniffiFfiConverterOptionalTypeImageDimensions.check_lower(value.dimensions)
        _UniffiFfiConverterOptionalString.check_lower(value.blurhash)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterBytes.write(value.encrypted_data, buf)
        _UniffiFfiConverterBytes.write(value.encrypted_hash, buf)
        _UniffiFfiConverterBytes.write(value.image_key, buf)
        _UniffiFfiConverterBytes.write(value.image_nonce, buf)
        _UniffiFfiConverterString.write(value.upload_secret_key, buf)
        _UniffiFfiConverterUInt64.write(value.original_size, buf)
        _UniffiFfiConverterUInt64.write(value.encrypted_size, buf)
        _UniffiFfiConverterString.write(value.mime_type, buf)
        _UniffiFfiConverterOptionalTypeImageDimensions.write(value.dimensions, buf)
        _UniffiFfiConverterOptionalString.write(value.blurhash, buf)

class _UniffiFfiConverterSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterSequenceString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterSequenceString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterSequenceString.read(buf) for i in range(count)
        ]

@dataclass
class KeyPackageResult:
    """
    Result of creating a key package
"""
    def __init__(self, *, key_package:str, tags:typing.List[typing.List[str]], hash_ref:bytes):
        self.key_package = key_package
        self.tags = tags
        self.hash_ref = hash_ref
        
        

    
    def __str__(self):
        return "KeyPackageResult(key_package={}, tags={}, hash_ref={})".format(self.key_package, self.tags, self.hash_ref)
    def __eq__(self, other):
        if self.key_package != other.key_package:
            return False
        if self.tags != other.tags:
            return False
        if self.hash_ref != other.hash_ref:
            return False
        return True

class _UniffiFfiConverterTypeKeyPackageResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeyPackageResult(
            key_package=_UniffiFfiConverterString.read(buf),
            tags=_UniffiFfiConverterSequenceSequenceString.read(buf),
            hash_ref=_UniffiFfiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.key_package)
        _UniffiFfiConverterSequenceSequenceString.check_lower(value.tags)
        _UniffiFfiConverterBytes.check_lower(value.hash_ref)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.key_package, buf)
        _UniffiFfiConverterSequenceSequenceString.write(value.tags, buf)
        _UniffiFfiConverterBytes.write(value.hash_ref, buf)

class _UniffiFfiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

@dataclass
class MdkConfig:
    """
    Configuration for MDK behavior

    This struct allows customization of various MDK parameters including
    message validation and MLS sender ratchet settings. All fields are optional
    and default to sensible values when not provided.
"""
    def __init__(self, *, max_event_age_secs:typing.Optional[int], max_future_skew_secs:typing.Optional[int], out_of_order_tolerance:typing.Optional[int], maximum_forward_distance:typing.Optional[int], epoch_snapshot_retention:typing.Optional[int], snapshot_ttl_seconds:typing.Optional[int]):
        self.max_event_age_secs = max_event_age_secs
        self.max_future_skew_secs = max_future_skew_secs
        self.out_of_order_tolerance = out_of_order_tolerance
        self.maximum_forward_distance = maximum_forward_distance
        self.epoch_snapshot_retention = epoch_snapshot_retention
        self.snapshot_ttl_seconds = snapshot_ttl_seconds
        
        

    
    def __str__(self):
        return "MdkConfig(max_event_age_secs={}, max_future_skew_secs={}, out_of_order_tolerance={}, maximum_forward_distance={}, epoch_snapshot_retention={}, snapshot_ttl_seconds={})".format(self.max_event_age_secs, self.max_future_skew_secs, self.out_of_order_tolerance, self.maximum_forward_distance, self.epoch_snapshot_retention, self.snapshot_ttl_seconds)
    def __eq__(self, other):
        if self.max_event_age_secs != other.max_event_age_secs:
            return False
        if self.max_future_skew_secs != other.max_future_skew_secs:
            return False
        if self.out_of_order_tolerance != other.out_of_order_tolerance:
            return False
        if self.maximum_forward_distance != other.maximum_forward_distance:
            return False
        if self.epoch_snapshot_retention != other.epoch_snapshot_retention:
            return False
        if self.snapshot_ttl_seconds != other.snapshot_ttl_seconds:
            return False
        return True

class _UniffiFfiConverterTypeMdkConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MdkConfig(
            max_event_age_secs=_UniffiFfiConverterOptionalUInt64.read(buf),
            max_future_skew_secs=_UniffiFfiConverterOptionalUInt64.read(buf),
            out_of_order_tolerance=_UniffiFfiConverterOptionalUInt32.read(buf),
            maximum_forward_distance=_UniffiFfiConverterOptionalUInt32.read(buf),
            epoch_snapshot_retention=_UniffiFfiConverterOptionalUInt32.read(buf),
            snapshot_ttl_seconds=_UniffiFfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterOptionalUInt64.check_lower(value.max_event_age_secs)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.max_future_skew_secs)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.out_of_order_tolerance)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.maximum_forward_distance)
        _UniffiFfiConverterOptionalUInt32.check_lower(value.epoch_snapshot_retention)
        _UniffiFfiConverterOptionalUInt64.check_lower(value.snapshot_ttl_seconds)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterOptionalUInt64.write(value.max_event_age_secs, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.max_future_skew_secs, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.out_of_order_tolerance, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.maximum_forward_distance, buf)
        _UniffiFfiConverterOptionalUInt32.write(value.epoch_snapshot_retention, buf)
        _UniffiFfiConverterOptionalUInt64.write(value.snapshot_ttl_seconds, buf)

class _UniffiFfiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

@dataclass
class Message:
    """
    Message representation
"""
    def __init__(self, *, id:str, mls_group_id:str, nostr_group_id:str, event_id:str, sender_pubkey:str, event_json:str, created_at:int, processed_at:int, kind:int, state:str):
        self.id = id
        self.mls_group_id = mls_group_id
        self.nostr_group_id = nostr_group_id
        self.event_id = event_id
        self.sender_pubkey = sender_pubkey
        self.event_json = event_json
        self.created_at = created_at
        self.processed_at = processed_at
        self.kind = kind
        self.state = state
        
        

    
    def __str__(self):
        return "Message(id={}, mls_group_id={}, nostr_group_id={}, event_id={}, sender_pubkey={}, event_json={}, created_at={}, processed_at={}, kind={}, state={})".format(self.id, self.mls_group_id, self.nostr_group_id, self.event_id, self.sender_pubkey, self.event_json, self.created_at, self.processed_at, self.kind, self.state)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.mls_group_id != other.mls_group_id:
            return False
        if self.nostr_group_id != other.nostr_group_id:
            return False
        if self.event_id != other.event_id:
            return False
        if self.sender_pubkey != other.sender_pubkey:
            return False
        if self.event_json != other.event_json:
            return False
        if self.created_at != other.created_at:
            return False
        if self.processed_at != other.processed_at:
            return False
        if self.kind != other.kind:
            return False
        if self.state != other.state:
            return False
        return True

class _UniffiFfiConverterTypeMessage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Message(
            id=_UniffiFfiConverterString.read(buf),
            mls_group_id=_UniffiFfiConverterString.read(buf),
            nostr_group_id=_UniffiFfiConverterString.read(buf),
            event_id=_UniffiFfiConverterString.read(buf),
            sender_pubkey=_UniffiFfiConverterString.read(buf),
            event_json=_UniffiFfiConverterString.read(buf),
            created_at=_UniffiFfiConverterUInt64.read(buf),
            processed_at=_UniffiFfiConverterUInt64.read(buf),
            kind=_UniffiFfiConverterUInt16.read(buf),
            state=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterString.check_lower(value.mls_group_id)
        _UniffiFfiConverterString.check_lower(value.nostr_group_id)
        _UniffiFfiConverterString.check_lower(value.event_id)
        _UniffiFfiConverterString.check_lower(value.sender_pubkey)
        _UniffiFfiConverterString.check_lower(value.event_json)
        _UniffiFfiConverterUInt64.check_lower(value.created_at)
        _UniffiFfiConverterUInt64.check_lower(value.processed_at)
        _UniffiFfiConverterUInt16.check_lower(value.kind)
        _UniffiFfiConverterString.check_lower(value.state)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterString.write(value.mls_group_id, buf)
        _UniffiFfiConverterString.write(value.nostr_group_id, buf)
        _UniffiFfiConverterString.write(value.event_id, buf)
        _UniffiFfiConverterString.write(value.sender_pubkey, buf)
        _UniffiFfiConverterString.write(value.event_json, buf)
        _UniffiFfiConverterUInt64.write(value.created_at, buf)
        _UniffiFfiConverterUInt64.write(value.processed_at, buf)
        _UniffiFfiConverterUInt16.write(value.kind, buf)
        _UniffiFfiConverterString.write(value.state, buf)

@dataclass
class UpdateGroupResult:
    """
    Result of updating a group
"""
    def __init__(self, *, evolution_event_json:str, welcome_rumors_json:typing.Optional[typing.List[str]], mls_group_id:str):
        self.evolution_event_json = evolution_event_json
        self.welcome_rumors_json = welcome_rumors_json
        self.mls_group_id = mls_group_id
        
        

    
    def __str__(self):
        return "UpdateGroupResult(evolution_event_json={}, welcome_rumors_json={}, mls_group_id={})".format(self.evolution_event_json, self.welcome_rumors_json, self.mls_group_id)
    def __eq__(self, other):
        if self.evolution_event_json != other.evolution_event_json:
            return False
        if self.welcome_rumors_json != other.welcome_rumors_json:
            return False
        if self.mls_group_id != other.mls_group_id:
            return False
        return True

class _UniffiFfiConverterTypeUpdateGroupResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UpdateGroupResult(
            evolution_event_json=_UniffiFfiConverterString.read(buf),
            welcome_rumors_json=_UniffiFfiConverterOptionalSequenceString.read(buf),
            mls_group_id=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.evolution_event_json)
        _UniffiFfiConverterOptionalSequenceString.check_lower(value.welcome_rumors_json)
        _UniffiFfiConverterString.check_lower(value.mls_group_id)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.evolution_event_json, buf)
        _UniffiFfiConverterOptionalSequenceString.write(value.welcome_rumors_json, buf)
        _UniffiFfiConverterString.write(value.mls_group_id, buf)

@dataclass
class Welcome:
    """
    Welcome representation
"""
    def __init__(self, *, id:str, event_json:str, mls_group_id:str, nostr_group_id:str, group_name:str, group_description:str, group_image_hash:typing.Optional[bytes], group_image_key:typing.Optional[bytes], group_image_nonce:typing.Optional[bytes], group_admin_pubkeys:typing.List[str], group_relays:typing.List[str], welcomer:str, member_count:int, state:str, wrapper_event_id:str):
        self.id = id
        self.event_json = event_json
        self.mls_group_id = mls_group_id
        self.nostr_group_id = nostr_group_id
        self.group_name = group_name
        self.group_description = group_description
        self.group_image_hash = group_image_hash
        self.group_image_key = group_image_key
        self.group_image_nonce = group_image_nonce
        self.group_admin_pubkeys = group_admin_pubkeys
        self.group_relays = group_relays
        self.welcomer = welcomer
        self.member_count = member_count
        self.state = state
        self.wrapper_event_id = wrapper_event_id
        
        

    
    def __str__(self):
        return "Welcome(id={}, event_json={}, mls_group_id={}, nostr_group_id={}, group_name={}, group_description={}, group_image_hash={}, group_image_key={}, group_image_nonce={}, group_admin_pubkeys={}, group_relays={}, welcomer={}, member_count={}, state={}, wrapper_event_id={})".format(self.id, self.event_json, self.mls_group_id, self.nostr_group_id, self.group_name, self.group_description, self.group_image_hash, self.group_image_key, self.group_image_nonce, self.group_admin_pubkeys, self.group_relays, self.welcomer, self.member_count, self.state, self.wrapper_event_id)
    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.event_json != other.event_json:
            return False
        if self.mls_group_id != other.mls_group_id:
            return False
        if self.nostr_group_id != other.nostr_group_id:
            return False
        if self.group_name != other.group_name:
            return False
        if self.group_description != other.group_description:
            return False
        if self.group_image_hash != other.group_image_hash:
            return False
        if self.group_image_key != other.group_image_key:
            return False
        if self.group_image_nonce != other.group_image_nonce:
            return False
        if self.group_admin_pubkeys != other.group_admin_pubkeys:
            return False
        if self.group_relays != other.group_relays:
            return False
        if self.welcomer != other.welcomer:
            return False
        if self.member_count != other.member_count:
            return False
        if self.state != other.state:
            return False
        if self.wrapper_event_id != other.wrapper_event_id:
            return False
        return True

class _UniffiFfiConverterTypeWelcome(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Welcome(
            id=_UniffiFfiConverterString.read(buf),
            event_json=_UniffiFfiConverterString.read(buf),
            mls_group_id=_UniffiFfiConverterString.read(buf),
            nostr_group_id=_UniffiFfiConverterString.read(buf),
            group_name=_UniffiFfiConverterString.read(buf),
            group_description=_UniffiFfiConverterString.read(buf),
            group_image_hash=_UniffiFfiConverterOptionalBytes.read(buf),
            group_image_key=_UniffiFfiConverterOptionalBytes.read(buf),
            group_image_nonce=_UniffiFfiConverterOptionalBytes.read(buf),
            group_admin_pubkeys=_UniffiFfiConverterSequenceString.read(buf),
            group_relays=_UniffiFfiConverterSequenceString.read(buf),
            welcomer=_UniffiFfiConverterString.read(buf),
            member_count=_UniffiFfiConverterUInt32.read(buf),
            state=_UniffiFfiConverterString.read(buf),
            wrapper_event_id=_UniffiFfiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiFfiConverterString.check_lower(value.id)
        _UniffiFfiConverterString.check_lower(value.event_json)
        _UniffiFfiConverterString.check_lower(value.mls_group_id)
        _UniffiFfiConverterString.check_lower(value.nostr_group_id)
        _UniffiFfiConverterString.check_lower(value.group_name)
        _UniffiFfiConverterString.check_lower(value.group_description)
        _UniffiFfiConverterOptionalBytes.check_lower(value.group_image_hash)
        _UniffiFfiConverterOptionalBytes.check_lower(value.group_image_key)
        _UniffiFfiConverterOptionalBytes.check_lower(value.group_image_nonce)
        _UniffiFfiConverterSequenceString.check_lower(value.group_admin_pubkeys)
        _UniffiFfiConverterSequenceString.check_lower(value.group_relays)
        _UniffiFfiConverterString.check_lower(value.welcomer)
        _UniffiFfiConverterUInt32.check_lower(value.member_count)
        _UniffiFfiConverterString.check_lower(value.state)
        _UniffiFfiConverterString.check_lower(value.wrapper_event_id)

    @staticmethod
    def write(value, buf):
        _UniffiFfiConverterString.write(value.id, buf)
        _UniffiFfiConverterString.write(value.event_json, buf)
        _UniffiFfiConverterString.write(value.mls_group_id, buf)
        _UniffiFfiConverterString.write(value.nostr_group_id, buf)
        _UniffiFfiConverterString.write(value.group_name, buf)
        _UniffiFfiConverterString.write(value.group_description, buf)
        _UniffiFfiConverterOptionalBytes.write(value.group_image_hash, buf)
        _UniffiFfiConverterOptionalBytes.write(value.group_image_key, buf)
        _UniffiFfiConverterOptionalBytes.write(value.group_image_nonce, buf)
        _UniffiFfiConverterSequenceString.write(value.group_admin_pubkeys, buf)
        _UniffiFfiConverterSequenceString.write(value.group_relays, buf)
        _UniffiFfiConverterString.write(value.welcomer, buf)
        _UniffiFfiConverterUInt32.write(value.member_count, buf)
        _UniffiFfiConverterString.write(value.state, buf)
        _UniffiFfiConverterString.write(value.wrapper_event_id, buf)



# MdkUniffiError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class MdkUniffiError(Exception):
    """
    Error type for MDK UniFFI operations
"""
    pass

_UniffiTempMdkUniffiError = MdkUniffiError

class MdkUniffiError:  # type: ignore
    """
    Error type for MDK UniFFI operations
"""
    
    class STORAGE(_UniffiTempMdkUniffiError):
        """
        Storage-related error
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "MdkUniffiError.STORAGE({})".format(str(self))
    _UniffiTempMdkUniffiError.STORAGE = STORAGE # type: ignore
    class MDK(_UniffiTempMdkUniffiError):
        """
        MDK core error
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "MdkUniffiError.MDK({})".format(str(self))
    _UniffiTempMdkUniffiError.MDK = MDK # type: ignore
    class INVALID_INPUT(_UniffiTempMdkUniffiError):
        """
        Invalid input parameter error
"""
        
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "MdkUniffiError.INVALID_INPUT({})".format(str(self))
    _UniffiTempMdkUniffiError.INVALID_INPUT = INVALID_INPUT # type: ignore

MdkUniffiError = _UniffiTempMdkUniffiError # type: ignore
del _UniffiTempMdkUniffiError


class _UniffiFfiConverterTypeMdkUniffiError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MdkUniffiError.STORAGE(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 2:
            return MdkUniffiError.MDK(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 3:
            return MdkUniffiError.INVALID_INPUT(
                _UniffiFfiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, MdkUniffiError.STORAGE):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, MdkUniffiError.MDK):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, MdkUniffiError.INVALID_INPUT):
            _UniffiFfiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, MdkUniffiError.STORAGE):
            buf.write_i32(1)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if isinstance(value, MdkUniffiError.MDK):
            buf.write_i32(2)
            _UniffiFfiConverterString.write(value._values[0], buf)
        if isinstance(value, MdkUniffiError.INVALID_INPUT):
            buf.write_i32(3)
            _UniffiFfiConverterString.write(value._values[0], buf)






class ProcessMessageResult:
    """
    Result of processing a message
"""
    def __init__(self):
        raise RuntimeError("ProcessMessageResult cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    @dataclass
    class APPLICATION_MESSAGE:
        """
        An application message (usually a chat message)
"""
        
        def __init__(self, message:Message):
            self.message = message
            
            """
        The processed message
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.APPLICATION_MESSAGE(message={})".format(self.message)
        def __eq__(self, other):
            if not other.is_APPLICATION_MESSAGE():
                return False
            if self.message != other.message:
                return False
            return True

    @dataclass
    class PROPOSAL:
        """
        A proposal message that was auto-committed by an admin receiver
"""
        
        def __init__(self, result:UpdateGroupResult):
            self.result = result
            
            """
        The proposal result containing evolution event and welcome rumors
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.PROPOSAL(result={})".format(self.result)
        def __eq__(self, other):
            if not other.is_PROPOSAL():
                return False
            if self.result != other.result:
                return False
            return True

    @dataclass
    class PENDING_PROPOSAL:
        """
        A pending proposal stored but not committed (receiver is not admin)
"""
        
        def __init__(self, mls_group_id:str):
            self.mls_group_id = mls_group_id
            
            """
        Hex-encoded MLS group ID this pending proposal belongs to
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.PENDING_PROPOSAL(mls_group_id={})".format(self.mls_group_id)
        def __eq__(self, other):
            if not other.is_PENDING_PROPOSAL():
                return False
            if self.mls_group_id != other.mls_group_id:
                return False
            return True

    @dataclass
    class EXTERNAL_JOIN_PROPOSAL:
        """
        External join proposal
"""
        
        def __init__(self, mls_group_id:str):
            self.mls_group_id = mls_group_id
            
            """
        Hex-encoded MLS group ID this proposal belongs to
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL(mls_group_id={})".format(self.mls_group_id)
        def __eq__(self, other):
            if not other.is_EXTERNAL_JOIN_PROPOSAL():
                return False
            if self.mls_group_id != other.mls_group_id:
                return False
            return True

    @dataclass
    class COMMIT:
        """
        Commit message
"""
        
        def __init__(self, mls_group_id:str):
            self.mls_group_id = mls_group_id
            
            """
        Hex-encoded MLS group ID this commit applies to
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.COMMIT(mls_group_id={})".format(self.mls_group_id)
        def __eq__(self, other):
            if not other.is_COMMIT():
                return False
            if self.mls_group_id != other.mls_group_id:
                return False
            return True

    @dataclass
    class UNPROCESSABLE:
        """
        Unprocessable message
"""
        
        def __init__(self, mls_group_id:str):
            self.mls_group_id = mls_group_id
            
            """
        Hex-encoded MLS group ID of the message that could not be processed
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.UNPROCESSABLE(mls_group_id={})".format(self.mls_group_id)
        def __eq__(self, other):
            if not other.is_UNPROCESSABLE():
                return False
            if self.mls_group_id != other.mls_group_id:
                return False
            return True

    @dataclass
    class IGNORED_PROPOSAL:
        """
        Proposal was ignored and not stored
"""
        
        def __init__(self, mls_group_id:str, reason:str):
            self.mls_group_id = mls_group_id
            
            """
        Hex-encoded MLS group ID this proposal was for
"""
        
            self.reason = reason
            
            """
        Reason the proposal was ignored
"""
        
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.IGNORED_PROPOSAL(mls_group_id={}, reason={})".format(self.mls_group_id, self.reason)
        def __eq__(self, other):
            if not other.is_IGNORED_PROPOSAL():
                return False
            if self.mls_group_id != other.mls_group_id:
                return False
            if self.reason != other.reason:
                return False
            return True

    @dataclass
    class PREVIOUSLY_FAILED:
        """
        Message was previously marked as failed and cannot be reprocessed

        This is returned when attempting to process a message that previously
        failed. Unlike throwing an error, this allows clients to handle the
        case gracefully without crashing.
"""
        
        def __init__(self, ):
            pass

    
            
            
    
        def __str__(self):
            return "ProcessMessageResult.PREVIOUSLY_FAILED()".format()
        def __eq__(self, other):
            if not other.is_PREVIOUSLY_FAILED():
                return False
            return True

    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_APPLICATION_MESSAGE(self) -> bool:
        return isinstance(self, ProcessMessageResult.APPLICATION_MESSAGE)
    def is_application_message(self) -> bool:
        return isinstance(self, ProcessMessageResult.APPLICATION_MESSAGE)
    def is_PROPOSAL(self) -> bool:
        return isinstance(self, ProcessMessageResult.PROPOSAL)
    def is_proposal(self) -> bool:
        return isinstance(self, ProcessMessageResult.PROPOSAL)
    def is_PENDING_PROPOSAL(self) -> bool:
        return isinstance(self, ProcessMessageResult.PENDING_PROPOSAL)
    def is_pending_proposal(self) -> bool:
        return isinstance(self, ProcessMessageResult.PENDING_PROPOSAL)
    def is_EXTERNAL_JOIN_PROPOSAL(self) -> bool:
        return isinstance(self, ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL)
    def is_external_join_proposal(self) -> bool:
        return isinstance(self, ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL)
    def is_COMMIT(self) -> bool:
        return isinstance(self, ProcessMessageResult.COMMIT)
    def is_commit(self) -> bool:
        return isinstance(self, ProcessMessageResult.COMMIT)
    def is_UNPROCESSABLE(self) -> bool:
        return isinstance(self, ProcessMessageResult.UNPROCESSABLE)
    def is_unprocessable(self) -> bool:
        return isinstance(self, ProcessMessageResult.UNPROCESSABLE)
    def is_IGNORED_PROPOSAL(self) -> bool:
        return isinstance(self, ProcessMessageResult.IGNORED_PROPOSAL)
    def is_ignored_proposal(self) -> bool:
        return isinstance(self, ProcessMessageResult.IGNORED_PROPOSAL)
    def is_PREVIOUSLY_FAILED(self) -> bool:
        return isinstance(self, ProcessMessageResult.PREVIOUSLY_FAILED)
    def is_previously_failed(self) -> bool:
        return isinstance(self, ProcessMessageResult.PREVIOUSLY_FAILED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ProcessMessageResult.APPLICATION_MESSAGE = type("ProcessMessageResult.APPLICATION_MESSAGE", (ProcessMessageResult.APPLICATION_MESSAGE, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.PROPOSAL = type("ProcessMessageResult.PROPOSAL", (ProcessMessageResult.PROPOSAL, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.PENDING_PROPOSAL = type("ProcessMessageResult.PENDING_PROPOSAL", (ProcessMessageResult.PENDING_PROPOSAL, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL = type("ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL", (ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.COMMIT = type("ProcessMessageResult.COMMIT", (ProcessMessageResult.COMMIT, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.UNPROCESSABLE = type("ProcessMessageResult.UNPROCESSABLE", (ProcessMessageResult.UNPROCESSABLE, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.IGNORED_PROPOSAL = type("ProcessMessageResult.IGNORED_PROPOSAL", (ProcessMessageResult.IGNORED_PROPOSAL, ProcessMessageResult,), {})  # type: ignore
ProcessMessageResult.PREVIOUSLY_FAILED = type("ProcessMessageResult.PREVIOUSLY_FAILED", (ProcessMessageResult.PREVIOUSLY_FAILED, ProcessMessageResult,), {})  # type: ignore




class _UniffiFfiConverterTypeProcessMessageResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ProcessMessageResult.APPLICATION_MESSAGE(
                _UniffiFfiConverterTypeMessage.read(buf),
            )
        if variant == 2:
            return ProcessMessageResult.PROPOSAL(
                _UniffiFfiConverterTypeUpdateGroupResult.read(buf),
            )
        if variant == 3:
            return ProcessMessageResult.PENDING_PROPOSAL(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 4:
            return ProcessMessageResult.EXTERNAL_JOIN_PROPOSAL(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 5:
            return ProcessMessageResult.COMMIT(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 6:
            return ProcessMessageResult.UNPROCESSABLE(
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 7:
            return ProcessMessageResult.IGNORED_PROPOSAL(
                _UniffiFfiConverterString.read(buf),
                _UniffiFfiConverterString.read(buf),
            )
        if variant == 8:
            return ProcessMessageResult.PREVIOUSLY_FAILED(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_APPLICATION_MESSAGE():
            _UniffiFfiConverterTypeMessage.check_lower(value.message)
            return
        if value.is_PROPOSAL():
            _UniffiFfiConverterTypeUpdateGroupResult.check_lower(value.result)
            return
        if value.is_PENDING_PROPOSAL():
            _UniffiFfiConverterString.check_lower(value.mls_group_id)
            return
        if value.is_EXTERNAL_JOIN_PROPOSAL():
            _UniffiFfiConverterString.check_lower(value.mls_group_id)
            return
        if value.is_COMMIT():
            _UniffiFfiConverterString.check_lower(value.mls_group_id)
            return
        if value.is_UNPROCESSABLE():
            _UniffiFfiConverterString.check_lower(value.mls_group_id)
            return
        if value.is_IGNORED_PROPOSAL():
            _UniffiFfiConverterString.check_lower(value.mls_group_id)
            _UniffiFfiConverterString.check_lower(value.reason)
            return
        if value.is_PREVIOUSLY_FAILED():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_APPLICATION_MESSAGE():
            buf.write_i32(1)
            _UniffiFfiConverterTypeMessage.write(value.message, buf)
        if value.is_PROPOSAL():
            buf.write_i32(2)
            _UniffiFfiConverterTypeUpdateGroupResult.write(value.result, buf)
        if value.is_PENDING_PROPOSAL():
            buf.write_i32(3)
            _UniffiFfiConverterString.write(value.mls_group_id, buf)
        if value.is_EXTERNAL_JOIN_PROPOSAL():
            buf.write_i32(4)
            _UniffiFfiConverterString.write(value.mls_group_id, buf)
        if value.is_COMMIT():
            buf.write_i32(5)
            _UniffiFfiConverterString.write(value.mls_group_id, buf)
        if value.is_UNPROCESSABLE():
            buf.write_i32(6)
            _UniffiFfiConverterString.write(value.mls_group_id, buf)
        if value.is_IGNORED_PROPOSAL():
            buf.write_i32(7)
            _UniffiFfiConverterString.write(value.mls_group_id, buf)
            _UniffiFfiConverterString.write(value.reason, buf)
        if value.is_PREVIOUSLY_FAILED():
            buf.write_i32(8)



class _UniffiFfiConverterBoolean:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiFfiConverterOptionalSequenceSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterSequenceSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterSequenceSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterSequenceSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterOptionalTypeGroup(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeGroup.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeGroup.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeGroup.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceTypeGroup(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeGroup.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeGroup.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeGroup.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalTypeMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeMessage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeMessage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeMessage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterSequenceTypeMessage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeMessage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeMessage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeMessage.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterSequenceTypeWelcome(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiFfiConverterTypeWelcome.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiFfiConverterTypeWelcome.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiFfiConverterTypeWelcome.read(buf) for i in range(count)
        ]

class _UniffiFfiConverterOptionalTypeWelcome(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeWelcome.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeWelcome.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeWelcome.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")


class MdkProtocol(typing.Protocol):
    """
    Main MDK instance with SQLite storage
"""
    
    def accept_welcome(self, welcome: Welcome) -> None:
        """
        Accept a welcome message
"""
        raise NotImplementedError
    def accept_welcome_json(self, welcome_json: str) -> None:
        """
        Accept a welcome message from JSON
"""
        raise NotImplementedError
    def add_members(self, mls_group_id: str,key_package_events_json: typing.List[str]) -> UpdateGroupResult:
        """
        Add members to a group
"""
        raise NotImplementedError
    def create_group(self, creator_public_key: str,member_key_package_events_json: typing.List[str],name: str,description: str,relays: typing.List[str],admins: typing.List[str]) -> CreateGroupResult:
        """
        Create a new group
"""
        raise NotImplementedError
    def create_key_package_for_event(self, public_key: str,relays: typing.List[str]) -> KeyPackageResult:
        """
        Create a key package for a Nostr event

        This function does NOT add the NIP-70 protected tag, ensuring maximum relay
        compatibility. Many popular relays (Damus, Primal, nos.lol) reject protected events.
        If you need the protected tag, use `create_key_package_for_event_with_options` instead.
"""
        raise NotImplementedError
    def create_key_package_for_event_with_options(self, public_key: str,relays: typing.List[str],protected: bool) -> KeyPackageResult:
        """
        Create a key package for a Nostr event with additional options

        # Arguments

        * `public_key` - The Nostr public key (hex) for the credential
        * `relays` - Relay URLs where the key package will be published
        * `protected` - Whether to add the NIP-70 protected tag. When `true`, relays that
        implement NIP-70 will reject republishing by third parties. However, many popular
        relays reject protected events entirely. Set to `false` for maximum relay
        compatibility.
"""
        raise NotImplementedError
    def create_message(self, mls_group_id: str,sender_public_key: str,content: str,kind: int,tags: typing.Optional[typing.List[typing.List[str]]]) -> str:
        """
        Create a message in a group
"""
        raise NotImplementedError
    def decline_welcome(self, welcome: Welcome) -> None:
        """
        Decline a welcome message
"""
        raise NotImplementedError
    def decline_welcome_json(self, welcome_json: str) -> None:
        """
        Decline a welcome message from JSON
"""
        raise NotImplementedError
    def get_group(self, mls_group_id: str) -> typing.Optional[Group]:
        """
        Get a group by MLS group ID
"""
        raise NotImplementedError
    def get_groups(self, ) -> typing.List[Group]:
        """
        Get all groups
"""
        raise NotImplementedError
    def get_last_message(self, mls_group_id: str,sort_order: str) -> typing.Optional[Message]:
        """
        Get the most recent message in a group according to the given sort order

        This is useful for clients that use `"processed_at_first"` sort order and need
        a "last message" value that is consistent with their `get_messages()` ordering.
        The cached `group.last_message_id` always reflects `"created_at_first"` ordering.

        # Arguments

        * `mls_group_id` - Hex-encoded MLS group ID
        * `sort_order` - Sort order: `"created_at_first"` or `"processed_at_first"`

        # Returns

        Returns the most recent message under the given ordering, or None if the group has no messages
"""
        raise NotImplementedError
    def get_members(self, mls_group_id: str) -> typing.List[str]:
        """
        Get members of a group
"""
        raise NotImplementedError
    def get_message(self, mls_group_id: str,event_id: str) -> typing.Optional[Message]:
        """
        Get a message by event ID within a specific group

        # Arguments

        * `mls_group_id` - The MLS group ID the message belongs to (hex-encoded)
        * `event_id` - The Nostr event ID to look up (hex-encoded)

        # Returns

        Returns the message if found, None otherwise
"""
        raise NotImplementedError
    def get_messages(self, mls_group_id: str,limit: typing.Optional[int],offset: typing.Optional[int],sort_order: typing.Optional[str]) -> typing.List[Message]:
        """
        Get messages for a group with optional pagination

        # Arguments

        * `mls_group_id` - Hex-encoded MLS group ID
        * `limit` - Optional maximum number of messages to return (defaults to 1000 if None)
        * `offset` - Optional number of messages to skip (defaults to 0 if None)
        * `sort_order` - Optional sort order: `"created_at_first"` (default) or `"processed_at_first"`

        # Returns

        Returns a vector of messages in the requested sort order
"""
        raise NotImplementedError
    def get_pending_welcomes(self, limit: typing.Optional[int],offset: typing.Optional[int]) -> typing.List[Welcome]:
        """
        Get pending welcomes with optional pagination

        # Arguments

        * `limit` - Optional maximum number of welcomes to return (defaults to 1000 if None)
        * `offset` - Optional number of welcomes to skip (defaults to 0 if None)

        # Returns

        Returns a vector of pending welcomes ordered by ID (descending)
"""
        raise NotImplementedError
    def get_relays(self, mls_group_id: str) -> typing.List[str]:
        """
        Get relays for a group
"""
        raise NotImplementedError
    def get_welcome(self, event_id: str) -> typing.Optional[Welcome]:
        """
        Get a welcome by event ID
"""
        raise NotImplementedError
    def leave_group(self, mls_group_id: str) -> UpdateGroupResult:
        """
        Create a proposal to leave the group
"""
        raise NotImplementedError
    def merge_pending_commit(self, mls_group_id: str) -> None:
        """
        Merge pending commit for a group
"""
        raise NotImplementedError
    def parse_key_package(self, event_json: str) -> str:
        """
        Parse a key package from a Nostr event
"""
        raise NotImplementedError
    def process_message(self, event_json: str) -> ProcessMessageResult:
        """
        Process an incoming MLS message
"""
        raise NotImplementedError
    def process_welcome(self, wrapper_event_id: str,rumor_event_json: str) -> Welcome:
        """
        Process a welcome message
"""
        raise NotImplementedError
    def remove_members(self, mls_group_id: str,member_public_keys: typing.List[str]) -> UpdateGroupResult:
        """
        Remove members from a group
"""
        raise NotImplementedError
    def self_update(self, mls_group_id: str) -> UpdateGroupResult:
        """
        Update the current member's leaf node in an MLS group
"""
        raise NotImplementedError
    def sync_group_metadata_from_mls(self, mls_group_id: str) -> None:
        """
        Sync group metadata from MLS
"""
        raise NotImplementedError
    def update_group_data(self, mls_group_id: str,update: GroupDataUpdate) -> UpdateGroupResult:
        """
        Update group data (name, description, image, relays, admins)
"""
        raise NotImplementedError

class Mdk(MdkProtocol):
    """
    Main MDK instance with SQLite storage
"""
    
    _handle: ctypes.c_uint64
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        handle = getattr(self, "_handle", None)
        if handle is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_mdk_uniffi_fn_free_mdk, handle)

    def _uniffi_clone_handle(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_mdk_uniffi_fn_clone_mdk, self._handle)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _uniffi_make_instance(cls, handle):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required handle.
        inst = cls.__new__(cls)
        inst._handle = handle
        return inst
    def accept_welcome(self, welcome: Welcome) -> None:
        """
        Accept a welcome message
"""
        
        _UniffiFfiConverterTypeWelcome.check_lower(welcome)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeWelcome.lower(welcome),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_accept_welcome,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def accept_welcome_json(self, welcome_json: str) -> None:
        """
        Accept a welcome message from JSON
"""
        
        _UniffiFfiConverterString.check_lower(welcome_json)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(welcome_json),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_accept_welcome_json,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def add_members(self, mls_group_id: str,key_package_events_json: typing.List[str]) -> UpdateGroupResult:
        """
        Add members to a group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterSequenceString.check_lower(key_package_events_json)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterSequenceString.lower(key_package_events_json),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUpdateGroupResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_add_members,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def create_group(self, creator_public_key: str,member_key_package_events_json: typing.List[str],name: str,description: str,relays: typing.List[str],admins: typing.List[str]) -> CreateGroupResult:
        """
        Create a new group
"""
        
        _UniffiFfiConverterString.check_lower(creator_public_key)
        
        _UniffiFfiConverterSequenceString.check_lower(member_key_package_events_json)
        
        _UniffiFfiConverterString.check_lower(name)
        
        _UniffiFfiConverterString.check_lower(description)
        
        _UniffiFfiConverterSequenceString.check_lower(relays)
        
        _UniffiFfiConverterSequenceString.check_lower(admins)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(creator_public_key),
            _UniffiFfiConverterSequenceString.lower(member_key_package_events_json),
            _UniffiFfiConverterString.lower(name),
            _UniffiFfiConverterString.lower(description),
            _UniffiFfiConverterSequenceString.lower(relays),
            _UniffiFfiConverterSequenceString.lower(admins),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeCreateGroupResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_group,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def create_key_package_for_event(self, public_key: str,relays: typing.List[str]) -> KeyPackageResult:
        """
        Create a key package for a Nostr event

        This function does NOT add the NIP-70 protected tag, ensuring maximum relay
        compatibility. Many popular relays (Damus, Primal, nos.lol) reject protected events.
        If you need the protected tag, use `create_key_package_for_event_with_options` instead.
"""
        
        _UniffiFfiConverterString.check_lower(public_key)
        
        _UniffiFfiConverterSequenceString.check_lower(relays)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(public_key),
            _UniffiFfiConverterSequenceString.lower(relays),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeKeyPackageResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def create_key_package_for_event_with_options(self, public_key: str,relays: typing.List[str],protected: bool) -> KeyPackageResult:
        """
        Create a key package for a Nostr event with additional options

        # Arguments

        * `public_key` - The Nostr public key (hex) for the credential
        * `relays` - Relay URLs where the key package will be published
        * `protected` - Whether to add the NIP-70 protected tag. When `true`, relays that
        implement NIP-70 will reject republishing by third parties. However, many popular
        relays reject protected events entirely. Set to `false` for maximum relay
        compatibility.
"""
        
        _UniffiFfiConverterString.check_lower(public_key)
        
        _UniffiFfiConverterSequenceString.check_lower(relays)
        
        _UniffiFfiConverterBoolean.check_lower(protected)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(public_key),
            _UniffiFfiConverterSequenceString.lower(relays),
            _UniffiFfiConverterBoolean.lower(protected),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeKeyPackageResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event_with_options,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def create_message(self, mls_group_id: str,sender_public_key: str,content: str,kind: int,tags: typing.Optional[typing.List[typing.List[str]]]) -> str:
        """
        Create a message in a group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterString.check_lower(sender_public_key)
        
        _UniffiFfiConverterString.check_lower(content)
        
        _UniffiFfiConverterUInt16.check_lower(kind)
        
        _UniffiFfiConverterOptionalSequenceSequenceString.check_lower(tags)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterString.lower(sender_public_key),
            _UniffiFfiConverterString.lower(content),
            _UniffiFfiConverterUInt16.lower(kind),
            _UniffiFfiConverterOptionalSequenceSequenceString.lower(tags),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_create_message,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def decline_welcome(self, welcome: Welcome) -> None:
        """
        Decline a welcome message
"""
        
        _UniffiFfiConverterTypeWelcome.check_lower(welcome)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterTypeWelcome.lower(welcome),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_decline_welcome,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def decline_welcome_json(self, welcome_json: str) -> None:
        """
        Decline a welcome message from JSON
"""
        
        _UniffiFfiConverterString.check_lower(welcome_json)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(welcome_json),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_decline_welcome_json,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_group(self, mls_group_id: str) -> typing.Optional[Group]:
        """
        Get a group by MLS group ID
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeGroup.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_group,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_groups(self, ) -> typing.List[Group]:
        """
        Get all groups
"""
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeGroup.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_groups,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_last_message(self, mls_group_id: str,sort_order: str) -> typing.Optional[Message]:
        """
        Get the most recent message in a group according to the given sort order

        This is useful for clients that use `"processed_at_first"` sort order and need
        a "last message" value that is consistent with their `get_messages()` ordering.
        The cached `group.last_message_id` always reflects `"created_at_first"` ordering.

        # Arguments

        * `mls_group_id` - Hex-encoded MLS group ID
        * `sort_order` - Sort order: `"created_at_first"` or `"processed_at_first"`

        # Returns

        Returns the most recent message under the given ordering, or None if the group has no messages
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterString.check_lower(sort_order)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterString.lower(sort_order),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeMessage.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_last_message,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_members(self, mls_group_id: str) -> typing.List[str]:
        """
        Get members of a group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_members,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_message(self, mls_group_id: str,event_id: str) -> typing.Optional[Message]:
        """
        Get a message by event ID within a specific group

        # Arguments

        * `mls_group_id` - The MLS group ID the message belongs to (hex-encoded)
        * `event_id` - The Nostr event ID to look up (hex-encoded)

        # Returns

        Returns the message if found, None otherwise
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterString.check_lower(event_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterString.lower(event_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeMessage.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_message,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_messages(self, mls_group_id: str,limit: typing.Optional[int],offset: typing.Optional[int],sort_order: typing.Optional[str]) -> typing.List[Message]:
        """
        Get messages for a group with optional pagination

        # Arguments

        * `mls_group_id` - Hex-encoded MLS group ID
        * `limit` - Optional maximum number of messages to return (defaults to 1000 if None)
        * `offset` - Optional number of messages to skip (defaults to 0 if None)
        * `sort_order` - Optional sort order: `"created_at_first"` (default) or `"processed_at_first"`

        # Returns

        Returns a vector of messages in the requested sort order
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterOptionalUInt32.check_lower(limit)
        
        _UniffiFfiConverterOptionalUInt32.check_lower(offset)
        
        _UniffiFfiConverterOptionalString.check_lower(sort_order)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterOptionalUInt32.lower(limit),
            _UniffiFfiConverterOptionalUInt32.lower(offset),
            _UniffiFfiConverterOptionalString.lower(sort_order),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeMessage.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_messages,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_pending_welcomes(self, limit: typing.Optional[int],offset: typing.Optional[int]) -> typing.List[Welcome]:
        """
        Get pending welcomes with optional pagination

        # Arguments

        * `limit` - Optional maximum number of welcomes to return (defaults to 1000 if None)
        * `offset` - Optional number of welcomes to skip (defaults to 0 if None)

        # Returns

        Returns a vector of pending welcomes ordered by ID (descending)
"""
        
        _UniffiFfiConverterOptionalUInt32.check_lower(limit)
        
        _UniffiFfiConverterOptionalUInt32.check_lower(offset)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterOptionalUInt32.lower(limit),
            _UniffiFfiConverterOptionalUInt32.lower(offset),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceTypeWelcome.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_pending_welcomes,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_relays(self, mls_group_id: str) -> typing.List[str]:
        """
        Get relays for a group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterSequenceString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_relays,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def get_welcome(self, event_id: str) -> typing.Optional[Welcome]:
        """
        Get a welcome by event ID
"""
        
        _UniffiFfiConverterString.check_lower(event_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(event_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterOptionalTypeWelcome.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_get_welcome,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def leave_group(self, mls_group_id: str) -> UpdateGroupResult:
        """
        Create a proposal to leave the group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUpdateGroupResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_leave_group,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def merge_pending_commit(self, mls_group_id: str) -> None:
        """
        Merge pending commit for a group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_merge_pending_commit,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def parse_key_package(self, event_json: str) -> str:
        """
        Parse a key package from a Nostr event
"""
        
        _UniffiFfiConverterString.check_lower(event_json)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(event_json),
        )
        _uniffi_lift_return = _UniffiFfiConverterString.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_parse_key_package,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def process_message(self, event_json: str) -> ProcessMessageResult:
        """
        Process an incoming MLS message
"""
        
        _UniffiFfiConverterString.check_lower(event_json)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(event_json),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeProcessMessageResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_process_message,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def process_welcome(self, wrapper_event_id: str,rumor_event_json: str) -> Welcome:
        """
        Process a welcome message
"""
        
        _UniffiFfiConverterString.check_lower(wrapper_event_id)
        
        _UniffiFfiConverterString.check_lower(rumor_event_json)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(wrapper_event_id),
            _UniffiFfiConverterString.lower(rumor_event_json),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeWelcome.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_process_welcome,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def remove_members(self, mls_group_id: str,member_public_keys: typing.List[str]) -> UpdateGroupResult:
        """
        Remove members from a group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterSequenceString.check_lower(member_public_keys)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterSequenceString.lower(member_public_keys),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUpdateGroupResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_remove_members,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def self_update(self, mls_group_id: str) -> UpdateGroupResult:
        """
        Update the current member's leaf node in an MLS group
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUpdateGroupResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_self_update,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def sync_group_metadata_from_mls(self, mls_group_id: str) -> None:
        """
        Sync group metadata from MLS
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
        )
        _uniffi_lift_return = lambda val: None
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_sync_group_metadata_from_mls,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)
    def update_group_data(self, mls_group_id: str,update: GroupDataUpdate) -> UpdateGroupResult:
        """
        Update group data (name, description, image, relays, admins)
"""
        
        _UniffiFfiConverterString.check_lower(mls_group_id)
        
        _UniffiFfiConverterTypeGroupDataUpdate.check_lower(update)
        _uniffi_lowered_args = (
            self._uniffi_clone_handle(),
            _UniffiFfiConverterString.lower(mls_group_id),
            _UniffiFfiConverterTypeGroupDataUpdate.lower(update),
        )
        _uniffi_lift_return = _UniffiFfiConverterTypeUpdateGroupResult.lift
        _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
        _uniffi_ffi_result = _uniffi_rust_call_with_error(
            _uniffi_error_converter,
            _UniffiLib.uniffi_mdk_uniffi_fn_method_mdk_update_group_data,
            *_uniffi_lowered_args,
        )
        return _uniffi_lift_return(_uniffi_ffi_result)





class _UniffiFfiConverterTypeMdk:
    @staticmethod
    def lift(value: int) -> Mdk:
        return Mdk._uniffi_make_instance(value)

    @staticmethod
    def check_lower(value: Mdk):
        if not isinstance(value, Mdk):
            raise TypeError("Expected Mdk instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Mdk) -> ctypes.c_uint64:
        return value._uniffi_clone_handle()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer) -> Mdk:
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw handle value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Mdk, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

class _UniffiFfiConverterOptionalTypeMdkConfig(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiFfiConverterTypeMdkConfig.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiFfiConverterTypeMdkConfig.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiFfiConverterTypeMdkConfig.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")

class _UniffiFfiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)
def decrypt_group_image(encrypted_data: bytes,expected_hash: typing.Optional[bytes],image_key: bytes,image_nonce: bytes) -> bytes:
    """
    Decrypt group image
"""
    
    _UniffiFfiConverterBytes.check_lower(encrypted_data)
    
    _UniffiFfiConverterOptionalBytes.check_lower(expected_hash)
    
    _UniffiFfiConverterBytes.check_lower(image_key)
    
    _UniffiFfiConverterBytes.check_lower(image_nonce)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(encrypted_data),
        _UniffiFfiConverterOptionalBytes.lower(expected_hash),
        _UniffiFfiConverterBytes.lower(image_key),
        _UniffiFfiConverterBytes.lower(image_nonce),
    )
    _uniffi_lift_return = _UniffiFfiConverterBytes.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_mdk_uniffi_fn_func_decrypt_group_image,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def derive_upload_keypair(image_key: bytes,version: int) -> str:
    """
    Derive upload keypair for group image
"""
    
    _UniffiFfiConverterBytes.check_lower(image_key)
    
    _UniffiFfiConverterUInt16.check_lower(version)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(image_key),
        _UniffiFfiConverterUInt16.lower(version),
    )
    _uniffi_lift_return = _UniffiFfiConverterString.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_mdk_uniffi_fn_func_derive_upload_keypair,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def new_mdk(db_path: str,service_id: str,db_key_id: str,config: typing.Optional[MdkConfig]) -> Mdk:
    """
    Create a new MDK instance with encrypted SQLite storage using automatic key management.

    This is the recommended constructor for production use. The database encryption key
    is automatically retrieved from (or generated and stored in) the platform's native
    keyring (Keychain on macOS/iOS, Keystore on Android, etc.).

    # Prerequisites

    The host application must initialize a platform-specific keyring store before calling
    this function:

    - **macOS/iOS**: `keyring_core::set_default_store(AppleStore::new())`
    - **Android**: Initialize from Kotlin (see Android documentation)
    - **Windows**: `keyring_core::set_default_store(WindowsStore::new())`
    - **Linux**: `keyring_core::set_default_store(KeyutilsStore::new())`

    # Arguments

    * `db_path` - Path to the SQLite database file
    * `service_id` - A stable, host-defined application identifier (e.g., "com.example.myapp")
    * `db_key_id` - A stable identifier for this database's key (e.g., "mdk.db.key.default")
    * `config` - Optional MDK configuration. If None, uses default configuration.

    # Errors

    Returns an error if:
    - No keyring store has been initialized
    - The keyring is unavailable or inaccessible
    - The database cannot be opened or created
"""
    
    _UniffiFfiConverterString.check_lower(db_path)
    
    _UniffiFfiConverterString.check_lower(service_id)
    
    _UniffiFfiConverterString.check_lower(db_key_id)
    
    _UniffiFfiConverterOptionalTypeMdkConfig.check_lower(config)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(db_path),
        _UniffiFfiConverterString.lower(service_id),
        _UniffiFfiConverterString.lower(db_key_id),
        _UniffiFfiConverterOptionalTypeMdkConfig.lower(config),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeMdk.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def new_mdk_unencrypted(db_path: str,config: typing.Optional[MdkConfig]) -> Mdk:
    """
    Create a new MDK instance with unencrypted SQLite storage.

     **WARNING**: This creates an unencrypted database. Sensitive MLS state
    including exporter secrets will be stored in plaintext.

    Only use this for development or testing. For production use, use `new_mdk`
    with an encryption key.

    # Arguments

    * `db_path` - Path to the SQLite database file
    * `config` - Optional MDK configuration. If None, uses default configuration.
"""
    
    _UniffiFfiConverterString.check_lower(db_path)
    
    _UniffiFfiConverterOptionalTypeMdkConfig.check_lower(config)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(db_path),
        _UniffiFfiConverterOptionalTypeMdkConfig.lower(config),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeMdk.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk_unencrypted,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def new_mdk_with_key(db_path: str,encryption_key: bytes,config: typing.Optional[MdkConfig]) -> Mdk:
    """
    Create a new MDK instance with encrypted SQLite storage using a directly provided key.

    Use this when you want to manage encryption keys yourself rather than using the
    platform keyring. For most applications, prefer `new_mdk` which handles key
    management automatically.

    # Arguments

    * `db_path` - Path to the SQLite database file
    * `encryption_key` - 32-byte encryption key (must be exactly 32 bytes)
    * `config` - Optional MDK configuration. If None, uses default configuration.

    # Errors

    Returns an error if the key is not 32 bytes or if the database cannot be opened.
"""
    
    _UniffiFfiConverterString.check_lower(db_path)
    
    _UniffiFfiConverterBytes.check_lower(encryption_key)
    
    _UniffiFfiConverterOptionalTypeMdkConfig.check_lower(config)
    _uniffi_lowered_args = (
        _UniffiFfiConverterString.lower(db_path),
        _UniffiFfiConverterBytes.lower(encryption_key),
        _UniffiFfiConverterOptionalTypeMdkConfig.lower(config),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeMdk.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_mdk_uniffi_fn_func_new_mdk_with_key,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)
def prepare_group_image_for_upload(image_data: bytes,mime_type: str) -> GroupImageUpload:
    """
    Prepare group image for upload
"""
    
    _UniffiFfiConverterBytes.check_lower(image_data)
    
    _UniffiFfiConverterString.check_lower(mime_type)
    _uniffi_lowered_args = (
        _UniffiFfiConverterBytes.lower(image_data),
        _UniffiFfiConverterString.lower(mime_type),
    )
    _uniffi_lift_return = _UniffiFfiConverterTypeGroupImageUpload.lift
    _uniffi_error_converter = _UniffiFfiConverterTypeMdkUniffiError
    _uniffi_ffi_result = _uniffi_rust_call_with_error(
        _uniffi_error_converter,
        _UniffiLib.uniffi_mdk_uniffi_fn_func_prepare_group_image_for_upload,
        *_uniffi_lowered_args,
    )
    return _uniffi_lift_return(_uniffi_ffi_result)

__all__ = [
    "InternalError",
    "MdkUniffiError",
    "ProcessMessageResult",
    "Group",
    "CreateGroupResult",
    "GroupDataUpdate",
    "ImageDimensions",
    "GroupImageUpload",
    "KeyPackageResult",
    "MdkConfig",
    "Message",
    "UpdateGroupResult",
    "Welcome",
    "decrypt_group_image",
    "derive_upload_keypair",
    "new_mdk",
    "new_mdk_unencrypted",
    "new_mdk_with_key",
    "prepare_group_image_for_upload",
    "Mdk",
    "MdkProtocol",
]